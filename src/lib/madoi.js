!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.madoi=t():e.madoi=t()}(self,(function(){return(()=>{"use strict";var e={d:(t,s)=>{for(var o in s)e.o(s,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:s[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{ShareClass:()=>o,shareConfigDefault:()=>n,Share:()=>i,getStateConfigDefault:()=>r,GetState:()=>a,SetState:()=>c,EnterRoom:()=>d,LeaveRoom:()=>h,PeerJoin:()=>l,PeerLeave:()=>f,newLoginRoom:()=>p,newUpdatePeerProfile:()=>u,newObjectDefinition:()=>g,newMethodDefinition:()=>m,newFunctionDefinition:()=>v,newInvocation:()=>y,newObjectState:()=>b,Madoi:()=>S});class s extends EventTarget{on(e,t){super.addEventListener(e,(e=>t(e.detail)))}fire(e,t){super.dispatchEvent(new CustomEvent(e,{detail:t}))}}function o(e={}){return e=>{}}const n={type:"beforeExec",maxLog:0,allowedTo:["USER"]};function i(e=n){const t=e;return t.type||(t.type="beforeExec"),t.maxLog||(t.maxLog=0),(e,s,o)=>{const n={share:t};e[s].madoiMethodConfig_=n}}const r={maxInterval:5e3};function a(e=r){const t=e;return(e,s,o)=>{const n={getState:t};e[s].madoiMethodConfig_=n}}function c(e={}){const t=e;return(e,s,o)=>{const n={setState:t};e[s].madoiMethodConfig_=n}}function d(e={}){const t=e;return(e,s,o)=>{const n={enterRoom:t};e[s].madoiMethodConfig_=n}}function h(e={}){const t=e;return(e,s,o)=>{const n={leaveRoom:t};e[s].madoiMethodConfig_=n}}function l(e={}){const t=e;return(e,s,o)=>{const n={peerJoin:t};e[s].madoiMethodConfig_=n}}function f(e={}){const t=e;return(e,s,o)=>{const n={peerLeave:t};e[s].madoiMethodConfig_=n}}function p(e){return{type:"LoginRoom",sender:void 0,castType:void 0,recipients:void 0,...e}}function u(e){return{type:"UpdatePeerProfile",sender:void 0,castType:void 0,recipients:void 0,...e}}function g(e){return{type:"ObjectDefinition",sender:void 0,castType:void 0,recipients:void 0,...e}}function m(e){return{type:"MethodDefinition",sender:void 0,castType:void 0,recipients:void 0,...e}}function v(e){return{type:"FunctionDefinition",sender:void 0,castType:void 0,recipients:void 0,...e}}function y(e,t){return{type:"Invocation",sender:void 0,castType:e,recipients:void 0,...t}}function b(e){return{type:"ObjectState",sender:void 0,castType:void 0,recipients:void 0,...e}}class S extends s{connecting=!1;interimQueue;sharedFunctions=[];sharedObjects=[];getStateMethods=new Map;setStateMethods=new Map;enterRoomMethods=new Map;leaveRoomMethods=new Map;peerJoinMethods=new Map;peerLeaveMethods=new Map;promises={};objectModifications=new Map;objectRevisions=new Map;handlers={};url;ws=null;selfPeerId=null;profile;peers=new Map;currentSender=null;lastObjRevision=null;constructor(e,t=null,s={},o={}){super(),this.profile=o,this.interimQueue=new Array,this.sendMessage(p({key:t||"",roomSpec:s,peerProfile:o}));const n=t?`?key=${t}`:"";if(e.match(/^wss?:\/\//))this.url=`${e}${n}`;else{const t=document.querySelector("script[src$='madoi.js']").src.split("/",5),s=("http:"==t[0]?"ws:":"wss:")+"//"+t[2]+"/"+t[3];this.url=`${s}/rooms/${e}${n}`}}start(){this.ws=new WebSocket(this.url),this.ws.onopen=e=>this.handleOnOpen(e),this.ws.onclose=e=>this.handleOnClose(e),this.ws.onerror=e=>this.handleOnError(e),this.ws.onmessage=e=>this.handleOnMessage(e),setInterval((()=>{this.saveStates()}),1e3)}getSelfPeerId(){return this.selfPeerId}getCurrentSenderPeerId(){return this.currentSender}isCurrentSenderSelf(){return this.currentSender==this.selfPeerId}getCurrentSenderPeer(){return this.currentSender?this.peers.get(this.currentSender):null}getObjRevision(){return this.lastObjRevision}close(){this.ws?.close()}handleOnOpen(e){this.connecting=!0;for(let e of this.interimQueue)this.ws?.send(JSON.stringify(e));this.interimQueue=[],this.onOpen(e)}handleOnClose(e){console.debug(`websocket closed because: ${e.reason}.`),this.connecting=!1,this.onClose(e),this.ws=null}handleOnError(e){this.onError(e)}handleOnMessage(e){var t=JSON.parse(e.data);this.currentSender=t.sender,this.data(t)}data(e){if("EnterRoom"==e.type){for(const[t,s]of this.enterRoomMethods)s(e.peerId,e.peers);this.selfPeerId=e.self.id,this.peers.set(e.self.id,{...e.self,profile:this.profile});for(const t of e.peers)this.peers.set(t.id,t);if(this.onEnterRoom(e.self,e.peers),this.fire("enterRoom",e),e.histories)for(const t of e.histories)this.data(t)}else if("LeaveRoom"==e.type){for(const[t,s]of this.leaveRoomMethods)s(e.peerId);this.onLeaveRoom(),this.fire("leaveRoom",{})}else if("PeerJoin"==e.type){this.peers.set(e.peer.id,e.peer);for(const[t,s]of this.peerJoinMethods)s(e.peerId);this.onPeerJoin(e.peer),this.fire("peerJoin",e)}else if("PeerLeave"==e.type){this.peers.delete(e.peerId);for(const[t,s]of this.peerLeaveMethods)s(e.peerId);this.onPeerLeave(e.peerId),this.fire("peerLeave",e)}else if("UpdatePeerProfile"==e.type){const t=this.peers.get(e.peerId);if(t){if(e.updates)for(const[s,o]of Object.entries(e.updates))t.profile[s]=o;if(e.deletes)for(const s of e.deletes)delete t.profile[s]}this.onUpdatePeerProfile(e.peerId,e.updates,e.deletes)}else if("Invocation"==e.type){const t=this.sharedFunctions[e.funcId];if(this.lastObjRevision=null,e.objRevision&&(this.lastObjRevision=e.objRevision),t){const s=this.applyInvocation(t,e.args);s instanceof Promise&&s.then((()=>{this.promises[e.funcId].resolve.apply(null,arguments)})).catch((()=>{this.promises[e.funcId].reject.apply(null,arguments)}))}else console.warn("no suitable method for ",e)}else if("ObjectState"==e.type){const t=this.setStateMethods.get(e.objId);t&&t(JSON.parse(e.state),e.revision),this.objectRevisions.set(e.objId,e.revision)}else{const t=e;if(this.handlers[t.type]){let e=null;t.sender&&(e=this.peers.get(t.sender)),this.handlers[t.type](t.body,e)}else this.onElse(t),this.fire("else",t)}}onOpen(e){}onClose(e){}onError(e){}onElse(e){}onEnterRoom(e,t){}onLeaveRoom(){}onPeerJoin(e){}onPeerLeave(e){}onUpdatePeerProfile(e,t,s){}send(e,t,s="BROADCAST"){this.ws&&this.sendMessage({type:e,castType:s,body:t})}unicast(e,t,s){this.sendMessage({type:e,castType:"UNICAST",recipients:[s],body:t})}multicast(e,t,s){this.sendMessage({type:e,castType:"MULTICAST",recipients:s,body:t})}broadcast(e,t){this.sendMessage({type:e,castType:"BROADCAST",body:t})}othercast(e,t){this.sendMessage({type:e,castType:"OTHERCAST",body:t})}setHandler(e,t){this.handlers[e]=t}clearHandler(e){delete this.handlers[e]}sendMessage(e){this.connecting?this.ws?.send(JSON.stringify(e)):this.interimQueue.push(e)}register(e,t=[]){if(!this.ws)return e;const s=e;if(s.madoiObjectId_)return console.warn("Ignore object registration because it's already registered."),e;const o=s.constructor.name,i=this.sharedObjects.length;this.sharedObjects.push(s),s.madoiObjectId_=i;const a=new Array,c=new Array,d=new Map;Object.getOwnPropertyNames(s.__proto__).forEach((e=>{const t=s[e];if("function"!=typeof t)return;if(!t.madoiMethodConfig_)return;const n=t.madoiMethodConfig_,i=a.length;d.set(e,i),a.push(t),c.push(m({name:e,config:n})),console.debug(`add config ${o}.${e}=${JSON.stringify(n)} from decorator`)}));for(const e of t){const t=e.method,s=t.name;let i;if(e.share)e.share.type||(e.share.type=n.type),e.share.maxLog||(e.share.maxLog=n.maxLog),i={share:e.share};else if(e.getState)e.getState.maxInterval||(e.getState.maxInterval=r.maxInterval),i={getState:e.getState};else if(e.setState)i={setState:e.setState};else if(e.enterRoom)i={enterRoom:e.enterRoom};else if(e.leaveRoom)i={leaveRoom:e.leaveRoom};else if(e.peerJoin)i={peerJoin:e.peerJoin};else{if(!e.peerLeave)continue;i={peerLeave:e.peerLeave}}const h=d.get(s);if(void 0===h){const n=a.length;d.set(s,n),a.push(t),c.push(m({name:e.method.name,config:i})),console.debug(`add config ${o}=${JSON.stringify(e)} from argument`)}else c[h].config=i,console.debug(`replace config ${o}=${JSON.stringify(e)} from argument`)}for(let e=0;e<a.length;e++){const t=a[e],o=c[e];if(o.config.share){const[e,n]=this.addSharedFunction(t.bind(s),o.config.share,i);o.funcId=e,this.objectModifications.set(i,0),this.objectRevisions.set(i,0);const r=this;s[t.name]=function(){const e=r.objectModifications.get(i);r.objectModifications.set(i,e+1);const t=r.objectRevisions.get(i);return r.objectRevisions.set(i,t+1),n.apply(null,arguments)}}else o.config.getState?this.getStateMethods.set(i,{method:t.bind(s),config:o.config.getState,lastGet:0}):o.config.setState?this.setStateMethods.set(i,t.bind(s)):o.config.enterRoom?this.enterRoomMethods.set(i,t.bind(s)):o.config.leaveRoom?this.leaveRoomMethods.set(i,t.bind(s)):o.config.peerJoin?this.peerJoinMethods.set(i,t.bind(s)):o.config.peerLeave&&this.peerLeaveMethods.set(i,t.bind(s))}const h=g({objId:i,className:o,methods:c});return this.sendMessage(h),e}registerFunction(e,t=n){t={...n,...t};const s=e.name,[o,i]=this.addSharedFunction(e,t);return this.sendMessage(v({funcId:o,name:s,config:t})),function(){return i.apply(null,arguments)}}addSharedFunction(e,t,s){const o=this.sharedFunctions.length;this.sharedFunctions.push(e),this.promises[o]={},this.promises[o].promise=new Promise(((e,t)=>{this.promises[o].resolve=e,this.promises[o].reject=t}));const n=this;return[o,function(){if(null!=n.ws){let i=null,r="BROADCAST";return"afterExec"==t.type&&(i=e.apply(null,arguments),r="OTHERCAST"),n.sendMessage(y(r,{objId:s,funcId:o,funcName:e.name,args:Array.from(arguments)})),null!=i?i:n.promises[o].promise}if(e)return e.apply(null,arguments)}]}saveStates(){if(this.ws&&this.connecting)for(let[e,t]of this.objectModifications){if(0==t)continue;const s=this.getStateMethods.get(e);if(!s)continue;const o=performance.now();(s.config.maxUpdates&&s.config.maxUpdates<=t||s.config.maxInterval&&s.config.maxInterval<=o-s.lastGet)&&(this.sendMessage(b({objId:e,state:JSON.stringify(s.method()),revision:this.objectRevisions.get(e)})),s.lastGet=o,this.objectModifications.set(e,0),console.log(`state saved: ${e}`))}}applyInvocation(e,t){return e.apply(null,t)}}return t})()}));